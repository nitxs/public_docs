## JS

1. ES5和ES6继承方式区别

- ES5定义类以函数形式, 以prototype来实现继承
- ES6以class形式定义类, 以extend形式继承

2. Generator了解

ES6提供的一种异步编程解决方案，Generator函数是一个状态机，封装了多个内部状态。

```javascript
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

let hw = helloWorldGenerator();

// 调用后返回指向内部状态的指针, 调用next()才会移向下一个状态, 参数:
hw.next()
// { value: 'hello', done: false }
hw.next()
// { value: 'world', done: false }
hw.next()
// { value: 'ending', done: true }
hw.next()
// { value: undefined, done: true }

```

3. async和await：

- Generator函数的语法糖，将*改成async，将yield换成await。
- 是对Generator函数的改进, 返回promise。
- 异步写法同步化，遇到await先返回，执行完异步再执行接下来的.
- 内置执行器, 无需next()

4. Promise调用实现

- 优点: 解决回调地狱, 对异步任务写法更标准化与简洁化
- 缺点: 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消; 其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部; 第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成)

```javascript
const myPromise = new Promise((resolve, reject) => {
  // 需要执行的代码
  // ...
  if (/* 异步执行成功 */) {
    resolve(value)
  } else if (/* 异步执行失败 */) {
    reject(error)
  }
})

// promise一旦新建就会立即执行
myPromise
.then( value => {
    // 成功后调用, 使用value值
    },err=>{
    // 失败后调用，使用error值
})
.catch( error => {
  // 当执行多个then时也可统一捕获失败，使用error值
} )
```

极简版promise封装：

```javascript
function Promise () {
  this.msg = '' // 存放value和error
  this.status = 'pending'
  const that = this
  const process = arguments[0]

  process (function () {
    that.status = 'fulfilled'
    that.msg = arguments[0]
  }, function () {
    that.status = 'rejected'
    that.msg = arguments[0]
  })
  return this
}

Promise.prototype.then = function () {
  if (this.status === 'fulfilled') {
    arguments[0](this.msg)
  } else if (this.status === 'rejected' && arguments[1]) {
    arguments[1](this.msg)
  }
}
```

5. 观察者模式

又称发布-订阅模式

```javascript
//定义发布订阅对象
let EventEmitter = function() {
    let cacheList = {},     //缓存列表，存放已订阅的事件回调
        listen,             //订阅命名事件和对应事件回调
        emit,               //触发命名事件，必传第一个参数为事件的命名，其后参数为选传，数量不限，用于作为事件回调的实参传入
        remove;             //取消命名事件订阅，并清除该命名事件对应的事件回调

    listen = function(key, fn) {
        //如果还没有订阅过此命名事件，就给该命名事件创建一个数组型的缓存列表，用于存放对应的事件回调
        if (!cacheList[key]) {
            cacheList[key] = []
        }

        //将对应的事件回调传入该命名事件的缓存列表中
        cacheList[key].push(fn)
    }

    emit = function() {
        let key = Array.prototype.shift.call(arguments),     //取出事件命名
            fns = cacheList[key];       //取出该命名事件对应的事件回调缓存列表

        //如果没有订阅该命名事件或对应的事件回调缓存列表为空数组，则直接返回false
        if (!fns || fns.length == 0) {
            return false;
        }

        // 遍历该命名事件对应的事件回调缓存列表数组，对数组中的每个事件回调传入处理后的实参列表，然后执行
        for (let i = 0; i < fns.length; i++) {
            // arguments为触发命名事件时传入的参数类数组，此时arguments已被取出索引为0处的事件命名，剩余元素就是要传入事件回调中的所有参数
            fns[i].apply(this, arguments)
        }
    }

    remove = function(key, fn) {
        // 获取将要被删除的事件命名的事件回调缓存列表
        let fns = cacheList[key]

        // 如果没有预存事件回调或该命名事件对应的事件回调缓存列表为空数组，直接返回false
        if (!fns || fns.length == 0) {
            return false;
        }

        if (!fn) {
            // 如果没有显式传入具体的事件回调函数，则清除该命名事件对应的所有事件回调缓存
            fns.length = 0
        } else {
            // 遍历事件命名对应的事件回调缓存列表，如传入要删除的事件回调函数与缓存列表数组中的某项匹配，就删除该项
            for (let l = fns.length - 1; l >= 0; l--) {
                let _fn = fns[l]
                if (_fn == fn) {
                    fns.splice(l, 1)
                }
            }
        }
    }

    return {
        cacheList,
        listen,
        emit,
        remove
    }
}

let emitter = new EventEmitter();
emitter.listen( "event1", function(data){
    console.log( data )
} )
emitter.emit( "event1", "数据1" )

```

6. 手写实现bind

```javascript
Function.prototype.bind = function () {
   // 保存原函数
  var self = this
  // 取出第一个参数作为上下文, 相当于[].shift.call(arguments)
  var context = Array.prototype.shift.call(arguments)
  // 取剩余的参数作为arg; 因为arguments是伪数组, 所以要转化为数组才能使用数组方法
  var arg = Array.prototype.slice.call(arguments)
  // 返回一个新函数
  return function () {
    // 绑定上下文并传参
    self.apply(context, Array.prototype.concat.call(arg, Array.prototype.slice.call(arguments)))
  }
}
```

7. 手写实现4种继承

```javascript
function Father () {}
function Child () {}

// 1. 原型继承
Child.prototype = new Father()

// 2. 构造继承
function Child (name) {
  Father.call(this, name)
}

// 3. 组合继承
function Child (name) {
  Father.call(this, name)
}
Child.prototype = new Father()

// 4. 寄生继承
function cloneObj (o) {
  var clone = object.create(o)
  clone.sayName = ...
  return clone
}

// 5. 寄生组合继承
// 6. ES6 class extend继承
class Child extends Father{
    super();
}
```

8. Object.create实现（原型式继承，特点：实例的proto指向构造函数本身）

9. 封装JSONP

```javascript
function jsonp ( {url, param, callback} ) {
  return new Promise((resolve, reject) => {
    // 创建script标签
    let script = document.createElement('script')
    window.callback = function (data) {
      resolve(data)
      //移除script标签  
      document.body.removeChild('script')
    }
    let param = {...param, callback}
    let arr = []
    for (let key in param) {
      arr.push(`${key}=${param[key]}`)
    }
    // 拼接url地址
    script.src = `${url}?${arr.join('&')}`
    // 将创建好的script标签添加到body下面
    document.body.appendChild(script)
  })
}
```

10. 对原型链的理解

11. setTimeout时间延迟为何不准

JS是单线程, 先执行同步主线程, 再执行异步任务队列

12. 事件循环述，宏任务和微任务有什么区别？

- 先主线程后异步任务队列
- 先微任务再宏任务

13. let const 作用

提供块级作用域, 暂时性死区

14. 节流和防抖

- 函数节流是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。
- 函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。

```javascript
// 函数节流   滚动条滚动
var canRun = true;
document.getElementById("throttle").onscroll = function(){
    if(!canRun){
        // 判断是否已空闲，如果在执行中，则直接return
        return;
    }

    canRun = false;
    setTimeout(function(){
        console.log("函数节流");
        canRun = true;
    }, 300);
};

// 函数防抖
var timer = false;
document.getElementById("debounce").onscroll = function(){
    clearTimeout(timer); // 清除未执行的代码，重置回初始化状态

    timer = setTimeout(function(){
        console.log("函数防抖");
    }, 300);
};
```

15. 实现一个sleep函数

这种sleep函数是最简单粗暴的，调用sleep函数会导致CPU占用高升，存在性能问题。执行环境兼容情况下可以另用async/await。

```javascript
// 这种实现方式是利用一个伪死循环阻塞主线程。因为JS是单线程的。所以通过这种方式可以实现真正意义上的sleep()。
function sleep(delay) {
  var start = (new Date()).getTime();
  while ((new Date()).getTime() - start < delay) {
    continue;
  }
}

function test() {
  console.log('111');
  sleep(2000);
  console.log('222');
}

test()
```

16. 闭包

- 概念: 内层函数能够访问外层函数作用域的变量
- 缺点: 引起内存泄漏（释放内存）
- 作用：
  - 使用闭包修正打印值
  - 实现柯里化
  - 实现node commonJs 模块化, 实现私有变量
  - 保持变量与函数活性, 可延迟回收和执行

17. JavaScript 模块化方案

##### IIFE 模块

为了避免全局污染，可以用匿名函数包裹起来，这就是最简单的 IIFE 模块
```javascript
// 定义 IIFE 模块
const iifeCounterModule = (() => {
    let count = 0;
    return {
        increase: () => ++count,
        reset: () => {
            count = 0;
            console.log("Count is reset.");
        }
    };
})();

// 使用 IIFE 模块
iifeCounterModule.increase();
iifeCounterModule.reset();

// 可以在模块内部直接使用依赖的全局变量，也可以把依赖作为参数传给 IIFE
// 定义带有依赖的 IIFE 模块
const iifeCounterModule = ((dependencyModule1, dependencyModule2) => {
    let count = 0;
    return {
        increase: () => ++count,
        reset: () => {
            count = 0;
            console.log("Count is reset.");
        }
    };
})(dependencyModule1, dependencyModule2);
```

##### CommonJS 模块（Node.js 模块）

CommonJS 最初叫 ServerJS，是由 Node.js 实现的模块化方案。默认情况下，每个 .js 文件就是一个模块，模块内部提供了一个module和exports变量，用于暴露模块的 API。使用 require 加载和使用模块。

```javascript
// 定义 CommonJS 模块: commonJSCounterModule.js.
const dependencyModule1 = require("./dependencyModule1");
const dependencyModule2 = require("./dependencyModule2");

let count = 0;
const increase = () => ++count;
const reset = () => {
    count = 0;
    console.log("Count is reset.");
};

exports.increase = increase;
exports.reset = reset;
// 或者这样：
module.exports = {
    increase,
    reset
};

// -----使用这个模块： 

// 使用 CommonJS 模块
const { increase, reset } = require("./commonJSCounterModule");
increase();
reset();
// 或者这样：
const commonJSCounterModule = require("./commonJSCounterModule");
commonJSCounterModule.increase();
commonJSCounterModule.reset();
```

##### AMD 模块（RequireJS 模块）

AMD（异步模块定义）也是一种模块格式，由 RequireJS 这个库实现。它通过define函数定义模块，并接受模块名和依赖的模块名作为参数。

```javascript
// 定义 AMD 模块
define("amdCounterModule", ["dependencyModule1", "dependencyModule2"], 
      (dependencyModule1, dependencyModule2) => {
    let count = 0;
    const increase = () => ++count;
    const reset = () => {
        count = 0;
        console.log("Count is reset.");
    };

    return {
        increase,
        reset
    };
});

// ------用 require加载和使用模块：

require(["amdCounterModule"], amdCounterModule => {
    amdCounterModule.increase();
    amdCounterModule.reset();
});

```

跟 CommonJS 不同，这里的 requrie接受一个回调函数，参数就是加载好的模块对象。

AMD 的define函数还可以动态加载模块，只要给它传一个回调函数，并带上 require参数：

```javascript
// Use dynamic AMD module.
define(require => {
    const dynamicDependencyModule1 = require("dependencyModule1");
    const dynamicDependencyModule2 = require("dependencyModule2");

    let count = 0;
    const increase = () => ++count;
    const reset = () => {
        count = 0;
        console.log("Count is reset.");
    };

    return {
        increase,
        reset
    };
});
```

AMD 模块还可以给define传递module和exports，这样就可以在内部使用 CommonJS 代码：

```javascript
// 定义带有 CommonJS 代码的 AMD 模块
define((require, exports, module) => {
    // CommonJS 代码
    const dependencyModule1 = require("dependencyModule1");
    const dependencyModule2 = require("dependencyModule2");

    let count = 0;
    const increase = () => ++count;
    const reset = () => {
        count = 0;
        console.log("Count is reset.");
    };

    exports.increase = increase;
    exports.reset = reset;
});

// 使用带有 CommonJS 代码的 AMD 模块
define(require => {
    // CommonJS 代码
    const counterModule = require("amdCounterModule");
    counterModule.increase();
    counterModule.reset();
});
```

##### UMD 模块

UMD（通用模块定义），是一种支持多种环境的模块化格式，可同时用于 AMD 和 浏览器（或者 Node.js）环境。看起来很复杂，其实就是个 IIFE

兼容 AMD 和浏览器全局引入：

```javascript
((root, factory) => {
    // 检测是否存在 AMD/RequireJS 的 define 函数
    if (typeof define === "function" && define.amd) {
        // 如果是，在 define 函数内调用 factory
        define("umdCounterModule", ["deependencyModule1", "dependencyModule2"], factory);
    } else {
        // 否则为浏览器环境，直接调用 factory
        // 导入的依赖是全局变量（window 对象的属性）
        // 导出的模块也是全局变量（window 对象的属性）
        root.umdCounterModule = factory(root.deependencyModule1, root.dependencyModule2);
    }
})(typeof self !== "undefined" ? self : this, (deependencyModule1, dependencyModule2) => {
    // 具体的模块代码
    let count = 0;
    const increase = () => ++count;
    const reset = () => {
        count = 0;
        console.log("Count is reset.");
    };

    return {
        increase,
        reset
    };
});
```

下面这个是兼容 AMD 和 CommonJS（Node.js）模块的 UMD：

```javascript
(define => define((require, exports, module) => {
    // 模块代码
    const dependencyModule1 = require("dependencyModule1");
    const dependencyModule2 = require("dependencyModule2");

    let count = 0;
    const increase = () => ++count;
    const reset = () => {
        count = 0;
        console.log("Count is reset.");
    };

    module.export = {
        increase,
        reset
    };
}))(// 判断 CommonJS 里的 module 变量和 exports 变量是否存在
    // 同时判断 AMD/RequireJS 的define 函数是否存在
    typeof module === "object" && module.exports && typeof define !== "function"
        ? // 如果是 CommonJS/Node.js，手动定义一个 define 函数
            factory => module.exports = factory(require, exports, module)
        : // 否则是 AMD/RequireJS，直接使用 define 函数
            define);
```

##### ES 模块（ES6 Module）

主要语法就是 import和epxort关键字

```javascript
// 定义 ES 模块：esCounterModule.js 或 esCounterModule.mjs.
import dependencyModule1 from "./dependencyModule1.mjs";
import dependencyModule2 from "./dependencyModule2.mjs";

let count = 0;
// 具名导出：
export const increase = () => ++count;
export const reset = () => {
    count = 0;
    console.log("Count is reset.");
};
// 默认导出
export default {
    increase,
    reset
};

//  ----- 浏览器里使用该模块，在 script标签上加上type="module"，表明引入的是 ES 模块。在 Node.js 环境中使用时，把扩展名改成 .mjs。

// Use ES module.
//浏览器： <script type="module" src="esCounterModule.js"></script> or inline.

// 服务器：esCounterModule.mjs
import { increase, reset } from "./esCounterModule.mjs";
increase();
reset();
// Or import from default export:
import esCounterModule from "./esCounterModule.mjs";
esCounterModule.increase();
esCounterModule.reset();

// 浏览器如果不支持，可以加个兜底属性：
<script nomodule>
    alert("Not supported.");
</script>
```

## 浏览器网络相关

1. reflow(回流)和repaint(重绘)优化

- 浏览器渲染过程: DOM tree, CSS tree --> Render tree --> Paint
- DOM tree根节点为html
- 渲染从浏览器左上角到右下角
- 第一次打开页面至少触发一次重绘和回流, 结构如宽高位置变化时, 触发reflow回流;非结构如背景色变化时, 触发repaint重绘. 二者都会造成体验不佳
- 如何减少重绘和回流?
    - 通过classname或cssText一次性修改样式, 而非一个一个改
    - 离线模式: 克隆要操作的结点, 操作后再与原始结点交换, 类似于虚拟DOM
    - 避免频繁直接访问计算后的样式, 而是先将信息保存下来
    - 绝对布局的DOM, 不会造成大量reflow
    - 不要嵌套太深, 不要超过六层

2. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

- 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
- 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
- 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM Tree）；
- 载入解析到的资源文件，渲染页面，完成。

3. localStorage 与 sessionStorage 与cookie的区别总结

- 共同点: 都保存在浏览器端, 且同源
- localStorage 与 sessionStorage 统称webStorage,保存在浏览器,不参与服务器通信,大小为5M
- 生命周期不同: localStorage永久保存, sessionStorage当前会话, 都可手动清除
- 作用域不同: 不同浏览器不共享local和session, 不同会话不共享session
- Cookie: 设置的过期时间前一直有效, 大小4K.有个数限制, 各浏览器不同, 一般为20个.携带在HTTP头中, 过多会有性能问题.可自己封装, 也可用原生

4. 浏览器如何阻止事件传播，阻止默认行为

- 阻止事件传播(冒泡): e.stopPropagation()
- 阻止默认行为: e.preventDefault()

5. 虚拟DOM方案相对原生DOM操作有什么优点，实现上是什么原理？

虚拟DOM可提升性能, 无须整体重新渲染, 而是局部刷新。JS对象, diff算法

6. 浏览器事件机制中事件触发三个阶段

- 事件捕获阶段: 从dom树节点往下找到目标节点, 不会触发函数
- 事件目标处理函数: 到达目标节点
- 事件冒泡: 最后从目标节点往顶层元素传递, 通常函数在此阶段执行
  
addEventListener第三个参数默认false(冒泡阶段执行),true(捕获阶段执行)

7. 什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？

- 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源
- 防止XSS、CSFR等攻击, 协议+域名+端口不同
- jsonp; 跨域资源共享（CORS）(Access control); 服务器正向代理等
- 预检请求: 需预检的请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响

8. 了解浏览器缓存机制吗？

- 浏览器缓存就是把一个已经请求过的资源拷贝一份存储起来，当下次需要该资源时，浏览器会根据缓存机制决定直接使用缓存资源还是再次向服务器发送请求
- from memory cache ; from disk cache
- 作用: 减少网络传输的损耗以及降低服务器压力。
- 优先级: 强制缓存 > 协商缓存; cache-control > Expires > Etag > Last-modified

9. 为什么操作 DOM 慢?

DOM本身是一个js对象, 操作这个对象本身不慢, 但是操作后触发了浏览器的行为, 如repaint和reflow等浏览器行为, 使其变慢

10. 什么情况会阻塞渲染

- js脚本同步执行
- css和图片虽然是异步加载, 但js文件执行需依赖css, 所以css也会阻塞渲染

11. 如何判断js运行在浏览器中还是node中

判断有无全局对象global和window

12. 关于web以及浏览器处理预加载有哪些思考

- 图片等静态资源在使用之前就提前请求
- 资源使用到的时候能从缓存中加载, 提升用户体验
- 页面展示的依赖关系维护

13. http多路复用

- Keep-Alive: Keep-Alive解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次HTTP请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是可以配置的，不管你用的是Apache还是nginx。
- 解决两个问题: 串行文件传输(采用二进制数据帧); 连接数过多(采用流, 并行传输)

14. http和https

- http: 最广泛网络协议，BS模型，浏览器高效。
- https: 安全版，通过SSL加密，加密传输，身份认证，密钥
    - https相对于http加入了ssl层, 加密传输, 身份认证;
    - 需要到ca申请收费的证书;
    - 安全但是耗时多，缓存不是很好;
    - 注意兼容http和https;
    - 连接方式不同, 端口号也不同, http是80, https是443

15. 正向代理和反向代理

正向代理:

- 访问原来无法访问的资源，如google
- 可以做缓存，加速访问资源
- 对客户端访问授权，上网进行认证
- 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

反向代理:

- 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。
- 负载均衡，通过反向代理服务器来优化网站的负载

