# Vue笔记

## 1.Vue模板语法

### 插值

vue中插入文本时使用双大括号语法，此时当绑定的数据对象值变动时，插值处的内容会实时更新。如果想执行一次性插值，当数据再次改变但插值处内容不会更新，可以使用`v-once`指令。

想要在模块上插入真正的html而非html代码，需要使用`v-html`指令。

如果想要动态修改html特性，如动态修改`id`、`disabled`之类的特性，可以使用`v-bind`指令。示例：`<span v-bind:id="dynamicId"></span>`，`<button v-bind:disabled="isButtonDisabled">btn</button>`。值得注意的是，当`isButtonDisabled`值为假时，`disabled`特性甚至不会被包含在渲染出来的`<button>`元素上。

### 指令

指令是带有 `v-` 前缀的特殊特性，它的职责是，当表达示的值改变时，将其产生的连带影响，响应式的作用于DOM。

指令有`v-if`、`v-for`、`v-bind`、`v-on`。后两个指令可以在指令名称之后添加 " 冒号 + 参数 "来监听DOM事件或响应式的更新DOM特性。

例如`<a v-bind:href="url"></a>`，这里的`href`就是指令参数，意指将`a`元素的`href`特性与表达式`url`的值绑定; `<p v-on:click="doSomething">监听DOM</p>`，这里的`click`就是监听的事件名，`doSomething`就是`click`事件对应的事件处理函数。

### 缩写

vue为`v-bind`和`v-on`这两个最常用的指令提供了特定简写：`<a v-bind:href="url"></a>`可以简写为`<a :href="url"></a>`；`<p v-on:click="doSomething">监听DOM</p>`可以简写为`<p @click="doSomething">监听DOM</p>`。

## 2.计算属性和侦听器

对于复杂逻辑，可以在表达式中使用**计算属性**，这个计算属性定义在`computed`对象中，计算属性是一个进行逻辑运算并必须返回运算结果的函数，可以像绑定普通属性一样在模板中绑定计算属性名。

### a.计算属性可缓存 / 方法不可缓存

如果计算属性中的运算逻辑依赖`data`对象中的数据属性(响应式依赖)，那么当对应的数据属性改变时，所有依赖该数据属性的计算属性就会重新求值。也就是说如果该数据属性值没有发生改变，即使多次访问计算属性也会立即返回之前的计算结果，而不必再次执行计算属性函数，这就是计算属性的特点：**可以缓存**。

通过在表达式中调用**方法**可以达到和计算属性一样的结果获取，但是**每当触发重新渲染时，调用方法总会再次执行。**

### b.计算属性 / 侦听属性

侦听属性`watch`是一种更通用的用于观察和响应Vue实例上数据变动的方式。但容易滥用，通常情况下推荐使用计算属性而非命令式的`watch`回调。但是当需要在数据变化时执行异步或开销较大的操作时，选择侦听属性`watch`是更合适的。

所以对于**计算属性computed**、**方法methods**和**侦听属性watch**，各自选用的场景建议如下：

- 对于同步且性能开销较大且响应式依赖`data`对象中数据属性的运算逻辑，可以使用计算属性`computed`，这样当依赖的数据属性值不变时即便多次访问该计算属性也会立即返回之前计算并缓存的运算求值结果，直到依赖的数据属性值改变再次访问该计算属性时才会重新执行运算逻辑函数；

- 对函数运算结果没有缓存需求的情况，推荐在方法`methods`中添加运算函数；

- 当需要在数据变化时执行异步或者开销较大的操作时，推荐在侦听属性`watch`中添加运算函数。

应用计算属性`computed`的实例：需要动态变化的样式Class对象、内联Style对象。

## 3.Class和Style绑定

动态控制元素的class和style属性列表是很常见的样式方面需求。在vue中由于它们都是属性，所以可以通过`v-bind`来处理：通过表达式计算出相应结果即可，结果类型可以是字符串、对象或数组。

### a.绑定html的class

#### ①.对象语法

通过传给`v-bind:class`一个对象，可以动态切换class；在该对象中可以传入多个属性来动态切换多个class；`v-bind:class`指令还可以和普通class属性共存；被绑定的class对象不必内联定义在模块中，可将class对象定义在`data`属性中。官方推荐一种常用且强大的模式是绑定一个返回class对象的计算属性，可以点击[这里](https://cn.vuejs.org/v2/guide/class-and-style.html)并 *搜索关键语句：绑定一个返回对象的计算属性* 快速查看官方示例。

#### ②.数组语法

也可以将一个数组传给`v-bind:class`以应用一个class列表；如果想根据条件来切换列表的class，可以使用三元表达式，当判断逻辑较复杂时可以在数组中使用对象语法。

#### ③.用于组件

当在一个自定义组件上使用class属性时，这些class类将被添加到该组件的根元素上，并且该根元素上已经存在的类不会被覆盖。

### b.绑定内联样式 Style

#### ①.对象形式

`v-bind:style`的对象语法很直观，看起来很像普通css代码，但其实是一个js对象。其中的css属性名可以使用驼峰命名或短横线分隔(用单引号括起来)命名；通常更好的写法是直接绑定到一个样式对象上，如`<div v-bind:style="styleObj"></div>`，这让模板更清晰；官方推荐的写法是对象语法结合返回对象的计算属性使用，这个和class绑定的官方推荐一样。

#### ②.数组形式

`v-bind:style`的数组语法可以将多个样式对象应用到同一个元素上，如`<div v-bind:style="[baseStylesObj, overridingStylesObj]"></div>`

#### ③.自动添加前缀

在使用`v-bind:style`时，vue会自动帮需要添加浏览器引擎前缀的css属性添加相应的前缀，例如`display:flex`或者`transform`之类的css属性。

## 4.条件渲染

vue中条件渲染有两种，分别是`v-if`和`v-show`。

其中`v-if`是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件会适当的被销毁和重建，同时它是惰性的，当初始渲染条件为假时就什么不做，直到条件首次为真时才会渲染条件块，所以`v-if`有更高的切换开销；

而`v-show`则不管初始条件是什么，元素总会被渲染，并且只是简单地基于css进行切换，所以`v-show`有更高的初始渲染开销。

所以业务运行时需频繁切换的场景推荐使用`v-show`，业务运行时很少改变条件的场景推荐使用`v-if`。

另外注意官方不推荐同时使用`v-if`和`v-for`。即使两者都被应用在同一节点时，`v-for`的优先级也高于`v-if`，这意味着`v-if`将分别重复运行于每个`v-for`循环中，当想仅渲染某些循环出来的节点时，这种优先机制会很用；而如果目的是有条件的跳过循环的执行，可以将`v-if`置于外层元素或者`<template>`元素上。

### a.条件渲染之 v-if

`v-if`指令被用于条件性的渲染一块内容。这块内容只会在指令的表达式返回真值时被渲染。

可以使用`v-if`、`v-else-if`和`v-else`进行元素的渲染条件判断。

由于`v-if`指令想要生效必须应用在某个具体元素上，所以当需求想根据某个判断条件同时渲染多个元素时，可以以`<template>`元素作为不可见的包裹元素包裹这些元素，并将`v-if`应用于`<template>`元素上。

vue会尽可能高效的渲染元素，所以通常会复用已有元素而不是重新渲染。比如当用户在不同登录场景切换时，切换出来的`input`输入框中已输入的内容不会被替换，因为vue使用的是同一个`input`元素，这样是为了提高渲染效率。但这不符合一些需求情况，它们会要求切换登录场景时重新渲染输入框以便清除之前输入的内容，此时就需要为输入框添加具有唯一值的属性`key`，它的作用是跟踪每个元素的身份从而重新渲染元素，具体代码示例可以看vue官方文档，点击[这里](https://cn.vuejs.org/v2/guide/conditional.html)并 *搜索关键语句：用key管理可复用的元素* 查看。

### b.条件渲染之 v-show

`v-show`指令也可条件展示元素。用法类似`v-if`，但是`v-show`不支持`template`元素，也不支持`v-else`。带有`v-show`的元素始终会被渲染并保留在DOM中，`v-show`也只是单纯切换元素的CSS属性`display`。

## 5.列表渲染

列表渲染采用`v-for`指令。

### a.用v-for通过数组元素迭代

`v-for`指令可以挨个渲染一组数组的所有迭代元素，使用的特殊语法是`item in items`，其中`items`是源数据数组，`item`是数组元素迭代别名。该特殊语法也可以写作`item of items`，即以`of`替代`in`作为分隔符，这类似于ES6中的迭代器语法。

`v-for`还支持一个可选的第二个参数作为当前项的索引，`(item, index) in items`。

在`v-for`循环的每个迭代块中，仍然拥有对父作用域属性的完全访问权限。

### b.用v-for通过对象属性迭代

`v-for`指令遍历对象时，使用的特殊语法是`value in object`，可以看到遍历出来的结果是对象迭代属性的值。

除了默认的参数`value`外，`v-for`还支持第二个参数作为键名，第三个参数为索引，`(value, key, index) in object`。

vue中遍历对象是按`Object.keys()`的结果遍历的，这不能保证它的结果在所有的JS引擎下都一致。结合`v-for`迭代数组元素的特性，可以看出官方推荐用于遍历的数据结构是：由对象为元素组成的数组。

### c.对v-for节点使用key

当vue使用`v-for`正在更新已经渲染过的元素列表时，默认使用"就地复用"策略，如果数据项的顺序被改变，vue将不会移动DOM元素来匹配数据项的顺序，而是简单地复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这种默认模式非常高效，但只适用于**不依赖子组件状态或临时DOM状态的列表渲染输出**。

如果需求需要能跟踪每个节点的身份，从而重用和重新排序现有元素，就需要为每项提供一个唯一`key`属性。这个`key`值应是每项都有的唯一id。

官方建议以在使用`v-for`时尽量提供绑定`key`值为最佳实践。

这个`key`是vue识别节点的一个通用机制，它不与`v-for`特别关联，还有其他用途。

设置`v-for`的`key`时应使用字符串或数据类型值，而不要使用对象或数组之类的非原始类型值。

### d.数组更新检测

vue中包含一组观察数组的变异方法，执行这些方法会改变被这些方法调用的原始数组并触发视图更新，这些方法为：`push()`、`pop()`、`shift()`、`unshift()`、`splice()`、`sort()`、`reverse()`。

相对的也有非变异方法，执行这些方法不会改变原始数组，但总是返回一个新数组。这些方法为：`filter()`、`concat()`和`slice()`。由于这些方法不改变原始数组，所以如想触发视图更新，就需要将返回的新数组替换旧数组，例如`this.itemArr = this.itemArr.filter( function( item ){ return item.message.match( /Foo/ ) } )`，以此主动更改原始数组从而触发视图更新，并且这种操作不会造成性能担忧，因为官方表示在vue中将含有相同元素的数组替换原数组是非常高效的操作。

注意：除了非变异方法不能主动触发视图更新外，还有两种数组变动情况不会主动触发视图更新：

- 当利用索引直接设置一个项时(`vm.items[indexOfItem] = newVal`)；
- 当直接修改数组长度时(`vm.items.length = newLength`)。
  
这两种数组变动操作都是非响应性。

为解决第一类问题，可以使用以下两种方式实现第一类问题效果并触发视图更新：`Vue.set( vm.items, indexOfItem, newValue )`或者`vm.items.splice( indexOfItem, 1, newValue )`。其中`Vue.set()`方法还可以换成该方法的别名`vm.$set()`，它们所传参数一样。

为解决第二类问题，可以使用`vm.items.splice( newLength )`实现相同效果并能触发视图更新。



