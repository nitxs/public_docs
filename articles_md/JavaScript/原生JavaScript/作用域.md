今天是2018年的最后一天，不管这一年当中有多少五味杂陈，统统都即将过去。

明天是新的一天，也是新的一年，预祝我自己，也预祝所有关注我公众号的朋友，新年一切安康。

本篇开始，读《你不知道的JavaScript》上中下三卷，并将读后总结奉上。

今天读上卷，第一部分作用域和闭包中的作用域。

## 作用域概念：

作用域指：一套设计良好的用来存储变量、并且之后可以方便找到这些变量的规则。

说的更细致点，作用域就是一套负责收集并维护所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

## 作用域中查询机制：

在作用域范围内中，引擎会对变量执行LHS查询和RHS查询。这两个查询从字面意思上理解就是查询赋值操作左侧的变量和查询赋值操作的右侧。

意思大致对，但并不完全精准，正确的理解应是：**查询赋值操作的目标(LHS)和查询赋值操作的源头(RHS)**。

## 嵌套作用域的查询路径：

在实际开发过程中，作用域常常不是只有一个，而是多个作用域嵌套的。即全局作用域可能包含若干个父局部作用域，一个父局部作用域又可能会包含若干个子局部作用域.....如此下去。当然也不可能嵌套层级太多，太多就晕，看到会想杀人的...

那么在存在嵌套作用域的情况下，某个变量的查询规则又是什么呢？很简单，在当前作用域中无法找到该变量时，引擎就会自变量所处当前作用域逐级向上冒泡般的查询，遵循就近原则，哪个作用域中最先查询到该变量，返回相应值后这事就算结束。或者直到抵达全局作用域也没有时，则返回个`undefined`就算了事。

## 总结下：

作用域是一套根据名称查询变量的规则，这套规则规定了在何处(嵌套层级)以及如何查找变量(LHS or RHS)。

如果查找的目的是对变量赋值，就会使用LHS查询；如果查找的目的是获取变量的值，就会使用RHS查询。

其中赋值操作符会导致RHS查询：=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

LHS和RHS查询都会在当前作用域中开始，如果没有在当前作用域找到所需的标识符，就会逐级向上级作用域查询目标标识符，直到找到为止或者没有找到时到全局作用域为止。