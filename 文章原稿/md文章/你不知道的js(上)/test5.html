<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
// function fn(){
//     console.log(this.a);
// }
// var a = 10;
// fn.call(null);      // 10
// function fn(a, b){
//     console.log( a*2 + b*3 );
// }
// fn.apply(null, [10, 4]);    //32
// function fn(a, b){
//     console.log( a*2 + b*3 );
// }
// var bar = fn.bind(null, 5);
// bar(7);     //

// function fn(a, b){
//     console.log( a*2 + b*3 );
// }
// //创建一个完全空对象，Object.create(null)和 {} 很像，但并不会创建Object.prototype这个委托，其比 {} 更空
// var Ø = Object.create(null);

// fn.apply( Ø, [10, 4] );      // 32

// // 使用bind()进行函数柯里化
// var bar = fn.bind( Ø,5 )
// bar(7);     // 31

// function fn(){
//     console.log(this.a);
// }
// var a = 10;
// var obj = {a:3, fn:fn};
// var p = {a:4};

// obj.fn();       // 3
// (p.fn = obj.fn)();      //10
// console.log( p.fn = obj.fn );

// if(!Function.prototype.softBind){
//     Function.prototype.softBind = function(obj){
//         var fn = this;
//         //捕获所有 curried 参数
//         var curried = [].slice.call( arguments, 1 );    // 将softBind()的参数从索引1处开始全部转变成数组
//         var bound = function(){
//             return fn.apply(
//                 (!this || this === (window || global)) ? obj : this,
//                 curried.concat.apply( curried, arguments )  //合并softBind传入的参数和 fn.apply()传入的参数为新数组
//             )
//         }
//         bound.prototype = Object.create( fn.prototype );
//         return bound;
//     }
// }

// function fn(){
//     console.log(this.a);
// }

// var a = 10;

// var obj1 = {a:1},
//     obj2 = {a:2},
//     obj3 = {a:3};

// var bar = fn.softBind(obj1);
// bar();      // 1

// obj2.fn = fn.softBind(obj1);
// obj2.fn();      // 2

// bar.call( obj3 );       // 3

// setTimeout(obj2.fn, 1000)   // 1

function fn(){
    setTimeout(function timer(){
        //这里的this继承自外层函数fn
        console.log(this.a)
    }, 1000)
}
var a = 10;
var obj = {a: 2};
fn.call(obj);   // 2

</script>
</html>