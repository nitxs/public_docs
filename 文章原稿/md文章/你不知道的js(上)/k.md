今天是2018年的最后一天，不管这一年当中有多少五味杂陈，统统都即将过去。

明天是新的一天，也是新的一年，预祝我自己，也预祝所有关注我公众号的朋友，新年一切安康。

本篇开始，读《你不知道的JavaScript》上中下三卷，并将读后总结奉上。

今天读上卷，第一部分作用域和闭包中的作用域。

## 作用域概念：

作用域指：一套设计良好的用来存储变量、并且之后可以方便找到这些变量的规则。

说的更细致点，作用域就是一套负责收集并维护所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

## 作用域中查询机制：

在作用域范围内中，引擎会对变量执行LHS查询和RHS查询。这两个查询从字面意思上理解就是查询赋值操作左侧的变量和查询赋值操作的右侧。

意思大致对，但并不完全精准，正确的理解应是：**查询赋值操作的目标(LHS)和查询赋值操作的源头(RHS)**。

## 嵌套作用域的查询路径：

在实际开发过程中，作用域常常不是只有一个，而是多个作用域嵌套的。即全局作用域可能包含若干个父局部作用域，一个父局部作用域又可能会包含若干个子局部作用域.....如此下去。当然也不可能嵌套层级太多，太多就晕，看到会想杀人的...

那么在存在嵌套作用域的情况下，某个变量的查询规则又是什么呢？很简单，在当前作用域中无法找到该变量时，引擎就会自变量所处当前作用域逐级向上冒泡般的查询，遵循就近原则，哪个作用域中最先查询到该变量，返回相应值后这事就算结束。或者直到抵达全局作用域也没有时，则返回个`undefined`就算了事。

## 总结下：

作用域是一套根据名称查询变量的规则，这套规则规定了在何处(嵌套层级)以及如何查找变量(LHS or RHS)。

如果查找的目的是对变量赋值，就会使用LHS查询；如果查找的目的是获取变量的值，就会使用RHS查询。

其中赋值操作符会导致RHS查询：=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

LHS和RHS查询都会在当前作用域中开始，如果没有在当前作用域找到所需的标识符，就会逐级向上级作用域查询目标标识符，直到找到为止或者没有找到时到全局作用域为止。

----------------------------------------------------------------------------------------------------------------------

《你不知道的JavaScript》第一部分作用域和闭包第2篇。

昨天讲到作用域，回顾下概念：作用域是一套用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找的规则。

## 常见的作用域形式
在JS中，最常见的作用域是函数作用域，其他结构通常不会创建作用域。但随着js的迭代，现在也有了块作用域，将在后面讲到。

而函数作用域的含义是指：属于这个函数的全部变量都可以在整个函数的范围内使用及复用，包括在嵌套的函数作用域中也可以使用。

函数作用域的常规套路是，先声明一个函数，然后向函数中添加代码实现。

但这个套路反过来也是很有用，即选取所写的一部分代码用函数声明来包装，从而将这些代码中的所有变量都绑定在新创建的包装函数的作用域中，而非先前所在的作用域中，目的就是通过新建作用域隐藏这些变量，能够尽可能少的暴露变量，这是符合软件开发的最小特权原则的。除此以外，"隐藏"作用域中的变量和函数还能规避同名标识符之间可能存在的冲突问题。

## 函数作用域的创建方式
函数作用域的创建需要声明一个函数，而声明函数这个行为又有函数声明和函数表达式两种操作方式。

函数声明和函数表达式的辨别，可以通过一个小技巧来一眼分辨：看`function`关键字出现在声明中的位置，注意，不仅仅是一行代码，而是整个声明中的位置，如果`function`是声明中的第一个词，那就是函数声明，否则就是函数表达式。
```javascript
function foo(){};   //函数声明

var foo = function(){};     //函数表达式

(function foo(){});     //函数表达式

（function(){       //匿名函数表达式

}）;
```

函数声明和函数表达式的区别是它们的名称标识符将会绑定在何处。举个例子：
```javascript
var a = 10;
function foo(a){
    var b = a * 2;
    return b;
}
console.log(foo);       //正确打印foo函数
foo();

(function fn(a){
    var c = a + 10;
    console.log(fn);    //正确打印fn函数
    return c;
})();
console.log(fn);    //ReferenceError: fn is not defined
```
上例中，假设代码所处作用域为全局作用域，`foo`函数的访问作用域是全局作用域，`fn`函数的访问作用域被绑定在函数表达式自身的函数中而非所在的全局作用域。此时，`fn`变量被隐藏在自身作用域中就意味着不会非必要的污染外部作用域。

在前文的函数表达式举例中，我还列出了匿名函数表达式，这种函数表达式的常用之地是回调函数，它是没有名称标识符的。函数表达式可以省略函数名，但函数声明则不可以省略函数名，否则会报错。

匿名函数表达式的应用非常常见，很多工具或库都有用到，但其也存在几个缺点：
- 匿名函数在栈中不显示有意义函数名，调试困难；
- 由于没有函数名，所以如需调用自身，比如递归或者事件触发后事件监听器需要解绑自身等，就不太好办了，除非使用`arguments.callee`，但这个已非官方推荐实践，将被彻底废弃；
- 同样由于没有函数名，导致代码可读性差，毕竟有个好的描述性名称，胜过额外添加注释。

正是由于以上三个缺点，所以比较推荐为匿名函数表达式加了名称标识符，这个操作不会对代码实现有任何影响，还能一举解决上面三个缺点，何乐不为：
```javascript
setTimeout(function foo(){
    console.log("哈哈，我有名称了.")
}, 1000)
//1秒后打印：
//哈哈，我有名称了.
```

## 块作用域
在ES5及之前版本中，js中的块作用域形同于无，实在要说的话，也只有`try-catch`中的`catch`部分定义的变量所在作用域是catch块中的，其他的都只是样子像，而本质上都不是块作用域，例如
```javascript
for(var i=0; i<10; i++){
    console.log(i);
}
console.log('外部:'+i);
// 外部：10
```
上例外部作用域可以访问到`i`的值为`10`。

但在ES6版本开始，有了`let`和`const`，终于可以明目张胆的定义块级作用域了，想必用惯了其他语言块级作用域的同学，心里的别扭终于可以舒口气了吧。

`let`关键字可以将变量绑定到所在的任意作用域中，通常是`{...}`内部，也就是说，`let`关键字为其声明的变量隐式的定义了所在的块级作用域。

`let`关键字发挥作用的典型在于`for`循环。
```javascript
for(let i=0; i<10; i++){
    console.log(i);
}
console.log(i);     //ReferenceError：i is not defined
```
你看，在外部作用域访问变量标识符`i`时，就直接报未定义的语法错误。

事实上，for循环头部的let不仅将i绑定到for循环的块中，在每次循环开始时，还将其重新绑定到新的循环迭代中去，确保使用上一个循环迭代结束时的值重新赋值。

至于`const`也是可以创建块作用域中，不同于`let`的是，其值是固定的常量，任何对其值的修改都会引起错误。

## 总结一下
js中的作用域，主要有函数作用域和块级作用域，当然还有全局作用域。

函数作用域的使用，可以隐藏代码实现，减少变量暴露，避免命名冲突，符合软件设计的最小特权原则。关于函数作用，还讲了函数声明与函数表达式的辨别方法和区别。在函数表达式中，还分出了命名函数表达式和匿名函数表达式。

块级作用域的实现，有赖于ES6的版本进步，提供`let`和`const`关键字，可以实现同其他语言相同的由`{...}`包裹起来的块级作用域。比较典型的就是`let`版的for循环和`var`版的for循环，感兴趣的可以自行了解。

----------------------------------------------------------------------------------------------------------------------

《你不知道的JavaScript》第一部分作用域和闭包第3篇。

前两篇主要讲作用域的查询机制和常见形式，本篇要讲的是作用域中的声明提升。

在全局作用域和局部作用域中，都存在声明提升的行为。

所谓声明，包括变量声明和函数声明。而声明提升，就是在作用域范围内，不管内部的变量与函数声明在何处，当执行到这个作用域时，引擎都会首先将当前作用域内的变量和函数声明放置到当前作用域顶端后，再按从上到下顺序执行其他代码。举例：
```javascript
//1.js
a = 2;
var a;
console.log(a);     // 输出=> 2

//2.js
console.log(b);     //  输出=> undefined
var b = 2;
```
经过变量提升后，实际为：
```javascript
//1.js
var a;  //将变量a声明提升到所在作用域顶端
a = 2;
console.log(a);     // 2

//2.js
var b;  //将变量b声明提升到所在作用域顶端
console.log(b);     // undefined
b = 2;
```

这里注意有个坑了：函数声明有提升行为，函数表达式不会有提升行为。
```javascript
foo();      // 输出=> 1
function foo(){
    console.log(1);
}

fn();       //输出TypeError
bar();      // 输出ReferenceError
var fn = function bar(){
    console.log(2);
}
```
问个问题：为什么`fn()`调用会报`TypeError`错误呢？ 因为此时的`fn`值为`undefined`，而对`undefined`调用方法，就会报`TypeError`错误。而使用为函数表达式添加的名称标识符`bar`进行方法调用时，输出的则是`ReferenceError`

另外还有个细节需要注意，在同时有变量声明和函数声明的提升行为中，引擎会执行函数优先的准则。即先提升函数，再提升变量。这再次证明果然js中函数是一等公民的地位。

最后总结下，js中的提升行为，面向的是对象是变量声明和函数声明，排除了包括函数表达式的赋值在内的赋值操作并不会提升。并且函数声明的优先级高于变量声明。

----------------------------------------------------------------------------------------------------------------------

《你不知道的JavaScript》第一部分作用域和闭包第4篇。

在掌握作用域的前提下，才能真正理解和识别闭包。

闭包：**当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。**
```javascript
function foo(){
    var a = 10;
    return function(){
        console.log(a*2);
    }
}
var fn = foo();
fn();   //20  => 闭包的效果
```
上述示例中，fn函数的词法作用域能够访问foo()函数的内部作用域。`foo()`函数以一个函数对象作为返回值。在`foo()`函数执行后，其返回值被赋值给了变量`fn`并调用`fn()`。实际上只是通过不同的标识符引用调用了这个被作为返回值的函数对象。

`fn()`可以被正常执行，并且还是在被自己定义的词法作用域之外执行。

这就是闭包的神奇了。通常一个函数在执行完毕后其内部作用域就会被销毁，但由于内部作用域此时仍然被标识符fn所指向的函数对象所引用，所以`foo()`函数的内部作用域不会被销毁，而这个引用就是闭包。

关于闭包，概念拎的差不多，再说也就那样，这玩意还是要能真悟到，不然还是会想不通的。

下面说个闭包的典型应用，for循环。
```javascript
for(var i=1; i<=5; i++){
    setTimeout(function timer(){
        console.log(i)
    }, i*1000)
}
//输出 => 6 6 6 6 6
```
上例结果是以每秒一次的频率输出6，而非设想的每秒一次的输出数字1~5。

出现这样非预期的情况，原因如下：
- js是单线程，只有同步代码执行完毕后，才会去执行异步代码。由于setTimeout是异步的，所以每次for循环时js都会挂起setTimeout这个异步任务，等到for循环这个同步任务执行完毕时，系统才会执行异步的任务队列，即执行setTimeout的回调函数。而当for循环执行完毕后，变量i的值就是6。
- 虽然for循环出来了五个延迟函数，但是根据作用域的工作原理，这五个延迟函数是被封闭在for循环所处的全局作用域内的。这个全局作用域中的变量i此时值已是6。所以五个延迟函数在执行时都读到同一个值为6的变量i，最后结果最后打印结果也就是五个6。

理解上面的原因，需要理解两个知识点：js中同步异步的执行顺序原理、作用域的工作原理。

找出了问题的原因，解决办法也就浮出水面了。如果能够让每个延迟函数time()都处于一个局部作用域中，并且该局部作用域中存在相应的变量i，让延迟函数timer()来访问该变量，不就行了么？创建局部作用域可以使用匿名函数自执行(IIFE)来做。

好，来搞个
```javascript
for(var i=1; i<=5; i++){
    (function(){
        setTimeout(function timer(){
            console.log(i);
        }, i*1000)
    })()
}
```
一打印，哦哟，咋还是以每秒一次的频率输出6哇，这不是已经把每个延迟函数单独放进一个局部作用域中了么？

再仔细一看，局部作用域里是空的，没有变量i，逼的timer()只能访问外层作用域中的变量i，所以此时需要将外层作用域中每次循环出来的变量i都传进每个局部作用域中去：
```javascript
for(var i=1; i<=5; i++){
    (function (j){
        setTimeout(function timer(){
            console.log(j)
        }, j*1000)
    })(i)
}
```
完美，此时就能顺利的达到预期设想了：每秒一次的输出数字1~5。

再回过头想想这个，正确执行的原理就是：将每个循环出来的timer()延迟函数放到一个单独的块作用域中去，并将循环出来的变量i值传入该单独块作用域中，如此，在块作用域中的函数可以随时访问所处作用域中的变量i。这其实就是闭包的实现。一个函数可以始终访问到所处作用域中的变量，而不管这个函数是否会在该作用域之外执行。

想到块作用域，ES6中的let关键字不是可以主动生成块作用域的么，把上例改一下，可以更简便的实现预期设想：
```javascript
for(let i=1; i<=5; i++){
    setTimeout(function timer(){
        console.log(i)
    }, i*1000)
}
//输出 => 1 (1s) 2 (1s) 3 (1s) 4 (1s) 5
```
完美! 

块作用域 + 闭包，简直不要太如鱼得水。

闭包的作用强大，还可以用来写模块。
```javascript
function foo(){
    var name = "nitx",
        skills = ['frontend', 'backend', 'db'];

    function showName(){
        console.log(name);
    }

    function showSkills(){
        var skillStr = skills.join("、");
        console.log(skillStr);
    }

    return {
        showName: showName,
        showSkills: showSkills
    }
}

var fn = foo();
fn.showName();
fn.showSkills();

/*
打印 =>
nitx
frontend、backend、db
*/
```
函数foo()在调用后形成一个闭包，其返回值是一个对象字面量，其作用是模块暴露，将其赋值给了一个模块实例标识符fn，通过fn来调用模块API方法。

上面这个示例中，每当foo()调用一次，就会生成一个模块实例，如果设想只能生成一个模块实例，可以使用IIFE来实现：
```javascript
var fn = (function foo(){
    var name = "nitx",
        skills = ['frontend', 'backend', 'db'];

    function showName(){
        console.log(name);
    }

    function showSkills(){
        var skillStr = skills.join("、");
        console.log(skillStr);
    }

    return {
        showName: showName,
        showSkills: showSkills
    }
})()
fn.showName();
fn.showSkills();
```
结果也是一样的。

这就是闭包的模块应用，当然在ES6版本后，官方提供了正规的模块模式，`import`、`export`等，这个可以自行去看相关资料，总之是很好用的。

最后来总结下闭包吧。

当函数可以始终记住并访问其所在作用域，即使该函数在该作用域之外执行，这种情况就产生了闭包。

闭包的形成需要两要素：存在访问目标的局部作用域、函数始终保持对该作用域的引用。

能用闭包的形式实现的，也可以用面向对象写法实现，反之亦然。

----------------------------------------------------------------------------------------------------------------------

《你不知道的JavaScript》第二部分`this`和对象原型第 1 篇。

本篇来看下js中的`this`关键字。

刚接触`this`关键字的时候，一脸懵逼，看字面意思很好理解，日常英语中的this指代“这个”，有指向的意思，难道这个关键字意思也是如此？作为纯自学起来的我，在踩了那么多坑后，已然条件反射般的感觉不对劲。果不其然，在新手阶段，我是看概念懵、抄demo懵、用起来更懵，完全不知什么鬼，这个this到底指向哪？关于这个`this`，硬啃了好久，经常一会懂一会懵的，工作中想用还不敢用了。后来勉强算熟手了，才算慢慢用起来，边用边理解，发现果然坑还是很多，但等到确实理解后，发现也没什么可怕的。人一胆大，就是一句话了：不要怂，就是干~~

好，先从最开始看这个`this`。

在全局作用域中，`this`指向全局变量；此外函数中的`this`关键字并不指向函数本身，以浏览器环境为例：
```javascript
var count = 0;
function fn(num){
    console.log("fn:" + num);
    console.log(this);      // window
    this.count++;
}
fn.count = 0;
for(var i=0; i<5; i++){
    fn(i);
}
console.log(fn.count);  // 0
console.log(count);     // 5
// for循环中fn函数执行5次
/*
fn:0
fn:1
fn:2
fn:3
fn:4
*/
```
从上例输出可以看到：
- 函数调用时，函数体内的this并不指向自身，因为函数fn中的this打印结果指向的是全局对象`window`，全局对象的属性`count`值最后打印为5；函数fn多次调用后函数属性`count`值依然是0，而非如预期的5。
- 函数体内的this不是指向函数本体，而是指向调用函数的对象。

那么针对上例，如果我想把函数中的`this`指向函数本身呢？可以使用js中的另一个神奇的武器：`call`或`apply`来修改this指向。
```javascript
function fn(num){
    console.log("fn: " + num);
    console.log(this);
    this.count ++;
}
fn.count = 0;
for(var i=0; i<5; i++){
    fn.call(fn, i);     //这里将fn函数内的this指向由指向全局对象window改为指向fn函数
}
console.log(fn.count);  // 5
console.log(count);     // ReferenceError: count is not defined
```
瞧，在fn函数调用时，通过`call`来修改fn函数内的this指向来达到递增fn函数属性count的目的。

上面两个小例子，只是`this`使用的起始，想用好this，先理解this的机制：

>`this`是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的条件。`this`的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。一句话：**`this`其实是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。**

关于上下文，很多人一直不理解或者似懂非懂，我觉得下面这段话讲的很到位：

当一个函数被**调用**时，会创建一个**活动记录(也叫执行上下文)**。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。`this`就是其中一个属性，会在函数执行过程中用到。

----------------------------------------------------------------------------------------------------------------------

《你不知道的JavaScript》第二部分`this`和对象原型第 2 篇。

关于`this`，之前说过，`this`的指向取决于函数调用位置而非函数定义位置。谁调用函数，则函数上下文中的`this`就指向谁。

概念很好理解，但实际使用时，坑实在是多，要注意看。

## 坑一：默认绑定。

在没有应用其他规则时，this绑定遵循默认绑定，但严格模式下与非严格模式下完全不同。
```javascript
//非严格模式
var a = 2;
function fn(){
    console.log(this.a);    // 2
}
fn();

//严格模式
function foo(){
    "use strict";
    console.log(this.a);    // TypeError: Cannot read property 'a' of undefined
}
foo(); 
```
看，非严格模式下，全局作用域中的函数调用时，函数词法作用域内的`this`指向全局对象`window`。而当严格模式时，函数调用时词法作用域内的`this`指向`undefined`，报 `TypeError`错误。

当然上例仅是举例，在实际开发中，不应混用严格与非严格模式。例外情况时引用到第三方库时可能会与原有代码有不同的严格模式，这个时候就有兼容性问题需要注意下。

## 坑二：隐式绑定。

当函数调用位置存在上下文对象时，可能会造成this指向出现意想不到的问题。用的时候需要注意。看下面例子：
```javascript
function fn(){
    console.log(this.a);   // 2
}
var obj = {
    a: 2,
    fn: fn
}
var a = 1;
obj.fn();
```
运行结果是 2 ，也就是取的obj对象属性a的值，而非取的全部对象属性a的值。原因是当函数fn被当作引用属性添加到obj中，调用位置会使用obj上下文来引用函数。即当fn()被调用时，该函数就引用了obj对象的上下文对象，此时隐式绑定规则就会把函数调用中的`this`绑定到这个上下文对象。所以`this.a`就和`obj.a`是一样的。

但这里就有坑了，看下面示例：
```javascript
function fn(){
    console.log(this.a);    // 1
}
var obj = {
    a: 2,
    fn: fn
}
var a = 1;
var foo = obj.fn;
foo();
```
咦，打印结果怎么变成 1 了？ 不应该是2么，fn()函数被当作引用属性添加到obj的上下文对象了呀？注意，这里坑就坑在`var foo = obj.fn`，这段代码又把fn()函数的引用赋值给了全局变量属性foo了。当调用foo()时，fn的上下文对象就变成全局作用域的了，好嘛，到obj对象里绕了一圈又出来，绝对坑你没商量的障眼法。

唔，上面这个还算好，仔细想想还容易从坑里爬出来，下面这个绝对就是个坑了：
```javascript
function fn(){
    console.log(this.a);
}
function bar(foo){
    foo();  //回调函数，高能预警 !!!
}
var obj = {
    a: 2,
    fn: fn
}
var a = 1;
bar( obj.fn );  // 1 
```
将`obj.fn`作为回调函数传入 `bar()` 函数中，其实我的理解就是把函数`fn`的指针由`obj.fn`换成`foo`罢了，此时调用 `bar()`函数时，内部执行的其实只是单纯的fn()函数，跟普通的默认绑定没啥区别，自然this也就指向全局对象喽。

这个坑非常微妙，很容易栽跟头。

当然如果把上面的bar()函数换成js内置函数如setTimeout，其结果也是一样的：
```javascript
function fn(){
    console.log(this.a);
}
var obj = {
    a: 2,
    fn: fn
}
var a = 1;
setTimeout(obj.fn, 1000);   // 1

//js内置延迟函数实现类似于下面：
function setTimeout(fn, delay){
    // 延迟 delay 时间执行
    fn();   // 调用位置
}
```
所以在回调函数中，this丢失绑定的情况一个不注意就会发生。

## 坑三显示绑定...

针对上面的情况，肯定是有解决办法。那就是用显示绑定，用函数的`call`或`apply`方法来强制绑定`this`。当然，这两个家伙的坑也是能埋人的...

首先这两个方法也有兼容性敢信？js的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法，尽管这样的函数非常罕见。js提供的绝大多数函数和用户自己创建的所有函数都可以使用`call`和`apply`方法。

其次需要明白这两个方法的工作机制：它们的第一个参数是个对象，它们会把这个对象绑定到this，接着在函数调用时指定这个this。如此由于是人为指定this的绑定对象，所以也称为显示绑定。看下面例子：
```javascript
function fn(){
    console.log(this.a);
}
var obj = {
    a: 20
}
fn.call(obj);       // 20
```
通过`fn.call()`，可以在函数fn调用时强制把它内部的this绑定到obj对象上面。如果传入的第一个参数是一个原始值(字符串类型、数字类型或布尔类型)来当作this的绑定对象，这个原始值就会被转换成它的对象形式(也就是 `new String(...)`、`new Number(...)`或者`new Boolean(...)`)。唔，这种操作叫做“装箱”，听起来好牛逼...

注意：从this绑定的角度来说，`call()`和`apply()`方法作用是完全一样的，它们的区别只是在于其他参数上，具体可以参考官方资料。

用`call()`和`apply()`方法绑定this 有两种实现方式：硬绑定和API绑定。

硬绑定：
```javascript
function fn(){
    console.log(this.a);
}
function bar(){
    fn.call(obj)
}
var obj = {
    a: 2
}
bar();      // 2
setTimeout(bar, 1000);  // 2

//即使重新绑定也无法修改
bar.call(window);   // 2
```
上述绑定的工作原理是：通过调用函数fn的call方法来将函数内部的this绑定到obj对象上，如此当fn函数调用时，函数内部this就指向了obj对象，`this.a`就和`obj.a`一样。这就是硬绑定。并且这种硬绑定完成后this的指向就是不可修改的。

这种硬绑定的应用场景非常广泛，多用于创建包裹函数，多种常用设计模式也会用到这种硬绑定:
```javascript
function fn(something){
    console.log(this.a, something);     // 2 4
    return this.a + something;
}
function bar(){
    return fn.apply(obj, arguments);
}
var obj = {
    a: 2
}
var res = bar(4);    
console.log(res);   // 6
```
还可以用来写成复用的方法，比如：
```javascript
// 可复用的辅助绑定函数
function bind(fn, obj){
    return function(){
        return fn.apply(obj, arguments);
    }
}

function fn(something){
    console.log(this.a, something);     // 2 5
    return this.a + something;
}
var obj = {a: 2};
var bar = bind(fn, obj);
var res = bar(5);
console.log(res);   // 7
```
当然上例中的辅助绑定函数其实在ES5中已有实现，就是`Function.prototype.bind`。一看这段代码就知，ES5中提供的`bind()`方法是挂载到Function的原型上，也就是说这个bind方法是个货真价实的实例方法，所有函数实例都可以用，来看看它怎么用：
```javascript
function fn(something){
    console.log(this.a, something);     // 2 6
    return this.a + something;
}
var obj = {a: 2};
var bar = fn.bind(obj);
var res = bar(6);
console.log(res);       // 8
```
不要去看mdn上面的解释，写的云山雾罩的，直接跟着这几个示例下来，就大致明白原生js中的bind()方法怎么回事了。bind()会返回一个对内部this硬绑定过的新函数，它会把参数obj设置为原函数this中的上下文并调用原函数。

## 坑四new绑定
什么叫new绑定呢？看如下代码：
```javascript
function Fn(a){
    this.a = a;
}
var bar = new Fn(10);
console.log(bar.a);
```
这段代码很熟悉吧。它就是常见的构造函数new一个对象。

熟悉面向对象语言的同学肯定更熟悉，这不就是从类里new出来一个对象么？比如`Student s = new Student();`从`Student`类里通过无参构造方法`Student()`来`new`一个对象`s`出来。那这个构造方法是不是就这js中构造函数呢？看起来好像啊。

其实在js中这样理解是错的。

js中本质上是没有类这样概念的，js是基于原型的。`Fn`虽然被称为构造函数，但其实不是真正的构造函数，它本质还是一个普通的函数，只是当它被用来new一个新对象时，才称其为构造函数，正确的理解应该是对函数的“构造调用”。

当使用 new 关键字来发生构造函数调用时，会自动执行如下过程：
- 创建(或是构造)一个全新的对象。
- 这个新对象会被执行原型连接。
- 这个新对象会被绑定到函数调用的this。
- 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

怎么理解上面这几句话呢？

当执行到 **new 函数调用** 时，如果函数中没有return出对象或者return的不是对象类型，则new表达式就会返回一个全新对象，否则返回的是函数内部return的对象。当new表达式函数调用返回创建出一个全新对象时，这个对象的原型是函数的prototype属性，并且**函数内部的this被绑定到这个全新对象上**。

上例代码就是这样理解的，Fn函数中的this被绑定到bar对象上。


----------------------------------------------------------------------------------------------------------------------

《你不知道的JavaScript》第二部分`this`和对象原型第 3 篇。

前面两篇讲了this的调用位置影响和绑定规则，在一般情况下想要弄清this的指向，只需找到函数的调用位置和并判断应当应用哪条绑定规则即可。但有时会出现某个调用位置可以应用多条绑定规则的情况，这个时候又该怎么办？也就是我们要弄清楚这些绑定规则的优先级问题。

首先可以知道**默认绑定**这条规则的优先级是最低的，所以在比较优化级条件时先剔除。

接下来就是要比较**隐式绑定**、**显式绑定**和**new绑定**。

先看隐式绑定和显示绑定。
```javascript
function fn(){
    console.log(this.a);
}
var obj1 = {
    a: 2,
    fn: fn
}
var obj2 = {
    a: 4,
    fn: fn
}
obj1.fn();   // 2
obj2.fn();   // 4

obj1.fn.call(obj2);     // 4
obj2.fn.call(obj1);     // 2
```
当对函数使用`call()`方法来进行this指向的显式绑定时，直接修改原先经隐式绑定上的值。

所以结论是：**显式绑定** 优先级 > **隐式绑定**

再来比较下隐式绑定和 new 绑定的优先级。
```javascript
function fn(something){
    this.a = something;
}
var obj1 = {
    fn: fn
}
var obj2 = {};
obj1.fn(2);
console.log(obj1.a);    // 2  

obj1.fn.call(obj2, 3);      
console.log(obj2.a);        // 3 

var bar = new obj1.fn(4);       
console.log(obj1.a);        // 2
console.log(bar.a);         // 4
```
代码解释：
`console.log(obj1.a);`  此时是隐式绑定，将this指向obj1对象，this.a操作就是在obj1对象上添加属性a，其值为fn函数传入的参数 2。

`obj1.fn.call(obj2, 3);` 此时是显式绑定，通过call方法将fn中this绑定到obj2对象上去，并且传入参数 3 来给obj2中属性a赋值 ，这里也再次印证 显式绑定优先级 高于 隐式绑定。

`var bar = new obj1.fn(4); `  对obj1.fn函数执行构造调用，返回一个新对象，obj1.fn函数中的this就指向这个新对象，并且构造调用时传入的参数 4 被赋值给了新对象的属性 a 。

所以结论是 **new 绑定** 优先级 > **隐式绑定** 。

好，现在有个初步结论，默认绑定 < 隐式绑定。

那么显式绑定和new绑定之间谁优先级高，再来比一比。

在举例前有个前提条件要先说下，new 和 call/apply 无法一起使用，因此无法通过 new fn.call(obj1) 来直接测试，但可以使用硬绑定来测试它们的优化级。毕竟硬绑定也是一种显式绑定。
```javascript
function fn(something){
    this.a = something;
}
var obj1 = {};
var bar = fn.bind(obj1);    // 通过bind硬绑定修改返回一个新函数，该函数中的this指向obj1
bar(2);
console.log(obj1.a);    // 2

var baz = new bar(4);       // 对bar函数执行构造调用，返回一个新对象baz，bar函数中的this指向新对象baz，构造调用时传入的参数 4 被赋值给 baz 对象 a
console.log(obj1.a);     // 2   
console.log(baz.a);     // 4
```
看到没！在代码执行过程中，先是通过bind方法返回一个新函数bar，bar函数内部的this此时是指向obj1 对象的，通过传入实参2，为obj1对象定义了一个值为2的属性a。然后再能bar函数进行构造调用新建了一个对象baz，并且在构造调用时传入实参4，其意思就是将bar函数中的this指向由obj1改为baz，并且通过`this.a`的赋值操作，为baz对象创建了一个值为4的属性a。由于这个new操作，其实已然修改bar函数中this的指针，所以obj1对象只是断开与this的连接，而其内部并未受到修改。所以最终打印结果就是如上所示。

所以结论是 **new绑定**优化级 > **显式绑定**。

最终this的四个绑定规则的优化级顺序为 **默认绑定** < **隐式绑定** < **显式绑定** < **new绑定**。

所以判断this的指向有一个比较完善的标准：

先查看函数的**调用位置**，然后再通过绑定规则来判定this指向：
- 函数如在new中调用，则函数中this绑定的就是新创建的对象，`var bar = new fn();`
- 函数如通过 call/apply 或者 硬绑定 调用，则this绑定是就是指定的对象，`var bar = fn.call(obj1);`、硬绑定`var baz = fn.bind(obj2);`
- 函数如果是在某个上下文对象中调用，即隐式绑定，则函数中this绑定的就是那个上下文对象，`var bar = obj.fn();`
- 如果以上情况都不是的话，就是默认绑定，这里分两种情况：如处于严格模式，则this被绑定到undefined上；如处于非严格模式，则this绑定到全局对象上。

以上就是this的绑定判断的标准答案了，但这是对于正常的函数调用的情况而言的。还是会有些例外情况的，时间关系，那些就留到下篇看吧。


----------------------------------------------------------------------------------------------------------------------

《你不知道的JavaScript》第二部分`this`和对象原型第 4 篇。

前篇说了this绑定的例外情况，比如当以为是应用的其他绑定规则时，其实应用的可能是默认绑定。

## 例外情况1：this忽略

当把null或者undefined作为this的绑定对象传入call、apply或bind时，这些值在调用时会被忽略，此时实际应用的是默认绑定规则。
```javascript
function fn(){
    console.log(this.a);
}
var a = 10;
fn.call(null);      // 10
```
上例这种传入null的情况是非常常见的。

比如用apply将某个数组展开以便传入某个不关心this的函数:
```javascript
function fn(a, b){
    console.log( a*2 + b*3 );
}
//把数组展开成参数传入函数fn中
fn.apply(null, [10, 4]);    //32
```
或者使用bind()来对参数进行柯里化(预先设置一些参数):
```javascript
function fn(a, b){
    console.log( a*2 + b*3 );
}
//通过bind()，返回一个新函数，该函数类似于fn的拷贝，并且传入 5 预设为a值
var bar = fn.bind(null, 5);
bar(7);     //31
```
上面两个示例方法都需要传入一个参数作为this的绑定对象，如果函数不关心this要绑定到何处，但又需要传入一个占位值，这里较好的选择是传入null。

这里有个小知识点，针对上面展开数组的操作，在ES6中可以通过`...`来代替apply()，即`fn(...[10, 4])`和`fn(10, 4)`是一样的，这样能够避免非必要的this绑定。但是ES6中没有相应的函数柯里化语法，所以仍然需要通过bind()来进行函数的柯里化。

唔，通常情况下，如果函数内不关心this指向，使用null来作为this的绑定对象是没有问题，但偶尔也会有些问题，比如函数用到第三库的方法时，可能this会有特定的绑定对象，此时如对函数的this进行上述绑定操作，容易产生一些难以觉查的bug，所以在不是完全确定的情况下，可以采用一种更佳实践(《你不知道的javascript》书中推荐)，将this绑定到一个完全为空的对象上：
```javascript
function fn(a, b){
    console.log( a*2 + b*3 );
}
//创建一个完全空对象，Object.create(null)和 {} 很像，但并不会创建Object.prototype这个委托，其比 {} 更空
var Ø = Object.create(null);

fn.apply( Ø, [10, 4] );      // 32

// 使用bind()进行函数柯里化
var bar = fn.bind( Ø,5 )
bar(7);     // 31
```

## 例外情况2： 函数的间接引用
这种情况在之前的示例中有出现过，函数的间接引用会出现在有意无意的函数赋值操作时发生：
```javascript
function fn(){
    console.log(this.a);
}
var a = 10;
var obj = {a:3, fn:fn};
var p = {a:4};

obj.fn();       // 3
(p.fn = obj.fn)();      //10
console.log( p.fn = obj.fn );   
/* 上行代码打印结果：
ƒ fn(){
    console.log(this.a);
}
*/
```
在上例中`p.fn = obj.fn`的返回值是目标函数fn的引用，因此调用位置是fn()而不是p.fn()。那么此时就是应用默认绑定。

这里有个小知识点要注意，对于默认绑定来说，决定this绑定对象的不是函数调用位置是否处于严格模式，而是函数定义位置的函数体是否处于严格模式。如果函数体处于严格模式，则this会被绑定到undefined上，否则就会绑定到全局对象上。

## 例外情况3： 软绑定
现在我们知道函数的绑定规则中有个叫显式绑定，其中又有一种比较特殊的绑定形式叫硬绑定，使用`Function.prototype.bind()`来实现，则ES5提供实现。这个硬绑定可以把this强制绑定到指定对象，从而防止函数调用应用默认绑定规则。

但这个硬绑定有个不足之处，即一旦对函数实施硬绑定，那除非使用new绑定外，其他绑定规则都不通再修改函数体的this绑定。显然会在一定程度上限制程序的灵活性。

那么是否有办法来实现既可以防止函数调用应用默认绑定规则，又可以方便灵活的再次修改this绑定呢？

办法是有的，和硬绑定通过Function.prototype来添加实例方法bind类似，具体实现过程如下：
```javascript
if(!Function.prototype.softBind){
    Function.prototype.softBind = function(obj){
        var fn = this;
        //捕获所有 curried 参数
        var curried = [].slice.call( arguments, 1 );    // 将softBind()的参数从索引1处开始全部转变成数组
        var bound = function(){
            return fn.apply(
                (!this || this === (window || global)) ? obj : this,
                curried.concat.apply( curried, arguments )  //合并softBind传入的参数和 fn.apply()传入的参数为新数组
            )
        }
        bound.prototype = Object.create( fn.prototype );
        return bound;
    }
}
```
解释： softBind()方法首先会检查调用时的this，如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this，否则不会修改this。

下面来看看这个软绑定是否起作用：
```javascript
function fn(){
    console.log(this.a);
}
var obj1 = {a:1},
    obj2 = {a:2},
    obj3 = {a:3};

var bar = fn.softBind(obj1);
bar();      // 1

obj2.fn = fn.softBind(obj1);
obj2.fn();      // 2

bar.call( obj3 );       // 3

setTimeout(obj2.fn, 1000)   // 1
```
可以看到，在将fn中this绑定到对象obj1后，再将函数引用赋值给obj2，即修改函数fn的调用位置上下文对象为obj2时，可以实现修改this绑定，使用call()修改this绑定对象也能工作。但如果应用默认规则时，则会将this绑定到obj。

唔，尽管这样起作用，但是我个人是不推荐直接修改 `Function.prototype`的，直接修改`Function`的原型，还是有隐患的，特别是在常规项目中，如非没有其他办法，一般不推荐这样修改污染原型对象。可以采用其他折中办法。

## 例外情况4： 箭头函数
在ES6中，箭头函数对this的对象绑定作用机制完全不一样。箭头函数并不是使用function关键字定义的。而是根据 `=>` 操作符定义的。

箭头函数不使用常规函数this的四种标准绑定规则，而是**根据外层(函数或全局)作用域来决定this绑定，并且一旦绑定就不可修改，即使是new绑定也不行**。
```javascript
function fn(){
    //返回一个箭头函数
    return a => {
        // this继承自fn()
        console.log(this.a);
    }
}

var obj1 = {a: 2},
    obj2 = {a: 3};

var bar = fn.call(obj1);
bar.call(obj2);     // 2 而不是3!
```
可以看到，fn函数返回一个箭头函数，根据箭头函数this的绑定规则，这个箭头函数中的this继承自外层函数fn中的this绑定的对象，也即是this绑定对象为obj1。

箭头函数常用的场景是回调函数中，比如事件处理器或者定时器：
```javascript
function fn(){
    setTimeout(()=>{
        //这里的this继承自外层函数fn
        console.log(this.a)
    }, 1000)
}

var obj = {a: 2};
fn.call(obj);   // 2
```
所以用箭头函数时，this绑定规则就很简单，直接继承自外层函数或全局作用域即可，不需要再去记常规函数的调用位置+4个绑定规则了。

箭头函数this试图用更常见的词法作用域来替代让人困扰的this机制(类似动态作用域)。

当然在ES5中也可以使用词法作用域来规避麻烦的this机制：
```javascript
function fn(){
    var self = this;
    setTimeout(function(){
        console.log(self.a);
    })
}
var obj = {a: 4};
fn.call(obj);   // 4
```
唔，这是一种取巧的办法。

所以通常来说，绑定函数的this对象，可以使用常规的this机制，也可以使用`self=this`或箭头函数来否定this机制，具体选哪个，看你更习惯哪种代码风格，没有谁优谁劣的，只要代码写出来注意优雅可维护就好。

最后，来为4篇this做个技术总结吧：
1. 有function关键字的函数内部关心this绑定的情况下，判定this绑定对象需要注意函数的调用位置和比较四种绑定规则
    - new绑定，优先级最高。this绑定到new 构造调用函数后创建出来的新对象上。
    - 显式绑定，优先级次之。由 call/apply或者bind 调用函数时指定的对象上
    - 隐式绑定，优先级再次之。由函数调用时上下文对象作为函数内部this绑定的对象。
    - 默认绑定，优先级最低。严格模式下this绑定到undefined，非严格模式下this绑定到全局对象。
2. 注意有些调用可能会无意中应用默认绑定规则，此时可以使用 `apply(null)`来忽略this绑定，更安全的做法是使用一个完全空集对象，例如`var Ø = Object.create(null); fn.apply(Ø);`，以保护全局对象
3. ES6中的箭头函数不遵循前述四种绑定规则，而是根据词法作用域来决定this绑定。即箭头函数会继承外层函数**调用**时的this绑定，并且不会管这个this绑定到底是什么。这点其实在ES5中已有实现，为`var self = this;`机制。